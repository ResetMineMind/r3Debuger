一个windows下r3层调试器的小demo， 希望能够最短的时间内开发完毕。其应当包含以下的处理逻辑：
	预备功能：
		1. 遍历当前的进程                 ok
		2. 附加已经运行的进程进行调试     ok 但是效果很一般
		3. 创建新的调试进程               ok
		4. 格式化用户的命令输入           ok
	调试功能：
		1. 设置软件断点                   ok
		2. 设置硬件断点                   ok
		3. 设置内存访问断点               ok
		4. 显示所有的软件断点             ok
		5. 显示所有的硬件断点             ok
		6. 显示所有的内存访问断点         ok
		7. 实现单步调试                   ok
		8. 实现步过                       ok
		9. 显示当前的栈数据，格式化输出   ok
		10. 清除指定类别的断点            ok
		（11. 打印当前的调用栈信息）
		12. 反汇编                        ok


在整体编程的过程中，由于需要考虑到多个软件断点、内存断点，导致编程难度变大，如何合理的调配
各个实现步骤成为一个大难题。
1. 软件断点的实现
	在软件断点实现的过程中，采用一个双向循环链表实现软件断点的设置与删除，同时由于软件断点导致的异常
需要更新线程上下文中的eip，因此此程序还存在着在call函数处调用软件断点，将导致无法步过对应函数。同时，
为了正常实现步入，还需要对当前指令的内容进行判断，如果当前指令是int 3，那么应当遍历全局断点链表，找到
对应的软件断点，并将其临时恢复。为了正常临时恢复断点，设置了一个全局的软件断点临时恢复数组，该数组负责
记录每次操作导致恢复的临时断点，并在下一次调试器捕获异常、用户输入命令前进行软件断点的重新设置。
2. 硬件断点的实现
	在硬件断点的实现过程中，需要使用到DR0,DR1,DR2,DR3,DR6,DR7此六个寄存器，DR6用于判断每次的硬件异常是
由哪一个寄存器中的地址所引发的，D7中设置LEN位、读写位、全局/局部断点位来声明一个硬件断点的断点长度、断点
类型。同时，硬件断点并不会导致线程上下文中EIP的偏离，因此不需要修复eip，但在执行之前，应当临时恢复硬件断
点。因此，本程序在用户操作指令真正执行前，先一步将临时硬件断点恢复，因此需要全局的硬件临时恢复数组。
	在此处应当特别注意，当软件断点、硬件断点、stepin设置的trap都在同一位置产生时，需要置为tf位，否则将在
此处循环触发三种/两种异常。
3. 内存断点的实现
	由于内存断点会设置整个页面属性为不可执行，因此在捕获EXCEPTION_ACCESS_VIOLATION后进行处理，由于如果临时
恢复了内存断点，会导致整个页面的断点都恢复执行，因此在执行run命令的时候会直接运行到程序结束或者下一个断点。
为了解决这个问题，将在EXCEPTION_ACCESS_VIOLATION里面，先判断是否是断点处，如果不是则将整个页面属性恢复，并
将此页面记录到内存断点临时恢复数组中，并触发一个STEPINM用户信号，此信号将会导致进入单步中断。如果此处正好是
内存断点地址，那么将会陷入用户操作，此时应当根据用户的选择来处理内存断点（当然，每次接受到新的调试消息时，会
自动将存储的临时内存断点恢复为断点）。
	在上述的情况下，一旦触发一个内存访问错误，若不是断点位置，将会导致进入STEPIN的处理流程，如果用户指令为si/so时，
这是正确的，但是如果用户指令是run，将会导致无法真正的run起来，仍然会单步中断。因此需要记录用户上次的选择，若选择了
run，则将lastCommand设置为1，直到用户再次输入si/so或者运行到内存断点处时，再将lastCommand置0。这样就可以保证，在访问
内存断点所在页面的非内存断点指令时，用户即使选择了run指令，也可以正常的自动处理其余内存访问断点导致发出的单步异常。
	自动处理内存访问异常的流程如下：
		1. 判断当前指令是否为断点指令
		2. 不是断点指令，直接将整页恢复为原页属性，并将页面记录至临时内存断点数组。（让程序执行）
		3. （下一个消息处理循环中）触发setpin，此时在再次获取异常消息时，将会从临时内存断点数组获取数据、依次重设断点。
		4. 上述三步，已经成功执行了一条指令。即自动处理了一条指令。
		5. 在STEPIN处理异常的分支中，若lastCommand不是1，将会陷入用户操作。
		6. 在STEPIN处理异常的分支中，若lastCommand是1，若没有硬件断点触发，将会跳过陷入用户操作，直接进入下一个循环。
			（默认情况下，run命令将会执行到下一个断点或者程序结束）
		7. 在STEPIN处理异常的分支中，若lastCommand是1，若有硬件断点触发，将会陷入用户操作，根据用户选择，处理硬件断点异常。
4. 各类异常的处理
	在本程序中，stepin\stepover\run都会将目前的指令进行判断，临时去除此指令处的软件断点、硬件断点、内存断点、单步trap。因此
恰当的处理各类异常有一定难度。

5. 本程序理论支持极多个内存断点和软件断点，4个硬件断点，但是一次性最多临时恢复512个软件断点、512个内存断点
（512是可以设置的，MAX_TMP_SOFT_BREAK，MAX_TMP_MEME_BREAK）。